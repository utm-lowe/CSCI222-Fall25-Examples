main ()
{
  struct basic_string D.36394;
  struct basic_string D.36393;
  struct allocator D.36392;
  struct basic_string D.36391;
  struct allocator D.36390;
  int D.40039;

  _1 = my_max<int> (1, 2);
  _2 = std::basic_ostream<char>::operator<< (&cout, _1);
  std::basic_ostream<char>::operator<< (_2, endl);
  _3 = my_max<double> (1.5e+0, 1.0699999999999999289457264239899814128875732421875e+1);
  _4 = std::basic_ostream<char>::operator<< (&cout, _3);
  std::basic_ostream<char>::operator<< (_4, endl);
  std::allocator<char>::allocator (&D.36392);
  try
    {
      try
        {
          std::__cxx11::basic_string<char>::basic_string (&D.36393, "one", &D.36392);
          try
            {
              try
                {
                  std::allocator<char>::allocator (&D.36390);
                  try
                    {
                      try
                        {
                          std::__cxx11::basic_string<char>::basic_string (&D.36391, "two", &D.36390);
                          try
                            {
                              try
                                {
                                  D.36394 = my_max<std::__cxx11::basic_string<char> > (&D.36391, &D.36393); [return slot optimization]
                                  try
                                    {
                                      try
                                        {
                                          _5 = std::operator<< <char, std::char_traits<char>, std::allocator<char> > (&cout, &D.36394);
                                          std::basic_ostream<char>::operator<< (_5, endl);
                                        }
                                      finally
                                        {
                                          std::__cxx11::basic_string<char>::~basic_string (&D.36394);
                                        }
                                    }
                                  finally
                                    {
                                      D.36394 = {CLOBBER};
                                    }
                                }
                              finally
                                {
                                  std::__cxx11::basic_string<char>::~basic_string (&D.36391);
                                }
                            }
                          finally
                            {
                              D.36391 = {CLOBBER};
                            }
                        }
                      finally
                        {
                          std::allocator<char>::~allocator (&D.36390);
                        }
                    }
                  finally
                    {
                      D.36390 = {CLOBBER};
                    }
                }
              finally
                {
                  std::__cxx11::basic_string<char>::~basic_string (&D.36393);
                }
            }
          finally
            {
              D.36393 = {CLOBBER};
            }
        }
      finally
        {
          std::allocator<char>::~allocator (&D.36392);
        }
    }
  finally
    {
      D.36392 = {CLOBBER};
    }
  D.40039 = 0;
  return D.40039;
}


my_max<int> (int a, int b)
{
  int D.40057;

  if (a > b) goto <D.40055>; else goto <D.40056>;
  <D.40055>:
  D.40057 = a;
  // predicted unlikely by early return (on trees) predictor.
  return D.40057;
  <D.40056>:
  D.40057 = b;
  // predicted unlikely by early return (on trees) predictor.
  return D.40057;
}


my_max<double> (double a, double b)
{
  double D.40061;

  if (a > b) goto <D.40059>; else goto <D.40060>;
  <D.40059>:
  D.40061 = a;
  // predicted unlikely by early return (on trees) predictor.
  return D.40061;
  <D.40060>:
  D.40061 = b;
  // predicted unlikely by early return (on trees) predictor.
  return D.40061;
}


std::allocator<char>::allocator (struct allocator * const this)
{
  try
    {
      {
        __gnu_cxx::new_allocator<char>::new_allocator (this);
        try
          {

          }
        catch
          {
            __gnu_cxx::new_allocator<char>::~new_allocator (this);
          }
      }
    }
  catch
    {
      <<<eh_must_not_throw (terminate)>>>
    }
}


__gnu_cxx::new_allocator<char>::new_allocator (struct new_allocator * const this)
{
  try
    {
      {

      }
    }
  catch
    {
      <<<eh_must_not_throw (terminate)>>>
    }
}


std::__cxx11::basic_string<char>::basic_string (struct basic_string * const this, const char * __s, const struct allocator & __a)
{
  const char * iftmp.0;

  MEM[(struct  &)this] = {CLOBBER};
  {
    _1 = &this->_M_dataplus;
    _2 = std::__cxx11::basic_string<char>::_M_local_data (this);
    std::__cxx11::basic_string<char>::_Alloc_hider::_Alloc_hider (_1, _2, __a);
    try
      {
        if (__s != 0B) goto <D.40064>; else goto <D.40065>;
        <D.40064>:
        _3 = std::char_traits<char>::length (__s);
        iftmp.0 = __s + _3;
        goto <D.40066>;
        <D.40065>:
        iftmp.0 = __s + 18446744073709551615;
        <D.40066>:
        std::__cxx11::basic_string<char>::_M_construct<const char*> (this, __s, iftmp.0);
      }
    catch
      {
        _4 = &this->_M_dataplus;
        std::__cxx11::basic_string<char>::_Alloc_hider::~_Alloc_hider (_4);
      }
  }
}


std::__cxx11::basic_string<char>::_Alloc_hider::_Alloc_hider (struct _Alloc_hider * const this, char * __dat, const struct allocator & __a)
{
  MEM[(struct  &)this] = {CLOBBER};
  {
    std::allocator<char>::allocator (this, __a);
    try
      {
        this->_M_p = __dat;
      }
    catch
      {
        std::allocator<char>::~allocator (this);
      }
  }
}


std::char_traits<char>::length (const char_type * __s)
{
  size_t D.40069;

  D.40069 = __builtin_strlen (__s);
  return D.40069;
}


std::__cxx11::basic_string<char>::_M_construct<const char*> (struct basic_string * const this, const char * __beg, const char * __end)
{
  struct _Integral D.38378;
  struct __false_type D.40071;
  typedef struct _Integral _Integral;

  try
    {
      std::__cxx11::basic_string<char>::_M_construct_aux<const char*> (this, __beg, __end, D.40071);
    }
  finally
    {
      D.38378 = {CLOBBER};
    }
}


std::__cxx11::basic_string<char>::_M_construct_aux<const char*> (struct basic_string * const this, const char * __beg, const char * __end, struct __false_type D.38416)
{
  struct forward_iterator_tag D.38822;
  struct _Tag D.38802;
  struct forward_iterator_tag D.40073;
  typedef struct _Tag _Tag;

  try
    {
      _1 = &D.38802;
      std::__cxx11::basic_string<char>::_M_construct<const char*> (this, __beg, __end, D.40073);
    }
  finally
    {
      D.38802 = {CLOBBER};
    }
}


std::__cxx11::basic_string<char>::_M_construct<const char*> (struct basic_string * const this, const char * __beg, const char * __end, struct forward_iterator_tag D.38816)
{
  bool retval.1;
  bool iftmp.2;
  size_type __dnew;

  try
    {
      _1 = __gnu_cxx::__is_null_pointer<const char> (__beg);
      if (_1 != 0) goto <D.40079>; else goto <D.40077>;
      <D.40079>:
      if (__beg != __end) goto <D.40080>; else goto <D.40077>;
      <D.40080>:
      iftmp.2 = 1;
      goto <D.40078>;
      <D.40077>:
      iftmp.2 = 0;
      <D.40078>:
      retval.1 = iftmp.2;
      if (retval.1 != 0) goto <D.40081>; else goto <D.40082>;
      <D.40081>:
      std::__throw_logic_error ("basic_string::_M_construct null not valid");
      <D.40082>:
      _2 = std::distance<const char*> (__beg, __end);
      _3 = (long unsigned int) _2;
      __dnew = _3;
      __dnew.3_4 = __dnew;
      if (__dnew.3_4 > 15) goto <D.40083>; else goto <D.40084>;
      <D.40083>:
      _5 = std::__cxx11::basic_string<char>::_M_create (this, &__dnew, 0);
      std::__cxx11::basic_string<char>::_M_data (this, _5);
      __dnew.4_6 = __dnew;
      std::__cxx11::basic_string<char>::_M_capacity (this, __dnew.4_6);
      goto <D.40085>;
      <D.40084>:
      <D.40085>:
      try
        {
          _7 = std::__cxx11::basic_string<char>::_M_data (this);
          std::__cxx11::basic_string<char>::_S_copy_chars (_7, __beg, __end);
        }
      catch
        {
          catch (NULL)
            {
              try
                {
                  _8 = __builtin_eh_pointer (0);
                  __cxa_begin_catch (_8);
                  std::__cxx11::basic_string<char>::_M_dispose (this);
                  __cxa_rethrow ();
                }
              finally
                {
                  __cxa_end_catch ();
                }
            }
        }
      __dnew.5_9 = __dnew;
      std::__cxx11::basic_string<char>::_M_set_length (this, __dnew.5_9);
    }
  finally
    {
      __dnew = {CLOBBER};
    }
}


__gnu_cxx::__is_null_pointer<const char> (const char * __ptr)
{
  bool D.40093;

  D.40093 = __ptr == 0B;
  return D.40093;
}


std::distance<const char*> (const char * __first, const char * __last)
{
  difference_type D.40095;
  struct iterator_category D.39845;
  struct random_access_iterator_tag D.40096;

  std::__iterator_category<const char*> (&__first);
  try
    {
      __first.6_1 = __first;
      D.40095 = std::__distance<const char*> (__first.6_1, __last, D.40096);
      return D.40095;
    }
  finally
    {
      D.39845 = {CLOBBER};
    }
}


std::__iterator_category<const char*> (const char * const & D.39844)
{
  struct iterator_category D.40099;

  return D.40099;
}


std::__distance<const char*> (const char * __first, const char * __last, struct random_access_iterator_tag D.39849)
{
  difference_type D.40101;

  D.40101 = __last - __first;
  return D.40101;
}


std::__cxx11::basic_string<char>::_Alloc_hider::~_Alloc_hider (struct _Alloc_hider * const this)
{
  {
    try
      {
        try
          {

          }
        finally
          {
            std::allocator<char>::~allocator (this);
          }
      }
    finally
      {
        MEM[(struct  &)this] = {CLOBBER};
      }
  }
  <D.37339>:
}


my_max<std::__cxx11::basic_string<char> > (struct basic_string & restrict a, struct basic_string & restrict b)
{
  bool retval.7;

  retval.7 = std::operator><char, std::char_traits<char>, std::allocator<char> > (a, b);
  if (retval.7 != 0) goto <D.40105>; else goto <D.40106>;
  <D.40105>:
  std::__cxx11::basic_string<char>::basic_string (<retval>, a);
  return <retval>;
  <D.40106>:
  std::__cxx11::basic_string<char>::basic_string (<retval>, b);
  return <retval>;
}


std::operator><char, std::char_traits<char>, std::allocator<char> > (const struct basic_string & __lhs, const struct basic_string & __rhs)
{
  bool D.40108;

  try
    {
      _1 = std::__cxx11::basic_string<char>::compare (__lhs, __rhs);
      D.40108 = _1 > 0;
      return D.40108;
    }
  catch
    {
      <<<eh_must_not_throw (terminate)>>>
    }
}


std::__cxx11::basic_string<char>::basic_string (struct basic_string * const this, struct basic_string & __str)
{
  bool retval.8;

  try
    {
      MEM[(struct  &)this] = {CLOBBER};
      {
        _1 = &this->_M_dataplus;
        _2 = std::__cxx11::basic_string<char>::_M_get_allocator (__str);
        _3 = std::move<std::allocator<char>&> (_2);
        _4 = std::__cxx11::basic_string<char>::_M_local_data (this);
        std::__cxx11::basic_string<char>::_Alloc_hider::_Alloc_hider (_1, _4, _3);
        try
          {
            retval.8 = std::__cxx11::basic_string<char>::_M_is_local (__str);
            if (retval.8 != 0) goto <D.40112>; else goto <D.40113>;
            <D.40112>:
            _5 = &__str->D.19187._M_local_buf;
            _6 = &this->D.19187._M_local_buf;
            std::char_traits<char>::copy (_6, _5, 16);
            goto <D.40114>;
            <D.40113>:
            _7 = std::__cxx11::basic_string<char>::_M_data (__str);
            std::__cxx11::basic_string<char>::_M_data (this, _7);
            _8 = __str->D.19187._M_allocated_capacity;
            std::__cxx11::basic_string<char>::_M_capacity (this, _8);
            <D.40114>:
            _9 = std::__cxx11::basic_string<char>::length (__str);
            std::__cxx11::basic_string<char>::_M_length (this, _9);
            _10 = std::__cxx11::basic_string<char>::_M_local_data (__str);
            std::__cxx11::basic_string<char>::_M_data (__str, _10);
            std::__cxx11::basic_string<char>::_M_set_length (__str, 0);
          }
        catch
          {
            _11 = &this->_M_dataplus;
            std::__cxx11::basic_string<char>::_Alloc_hider::~_Alloc_hider (_11);
          }
      }
    }
  catch
    {
      <<<eh_must_not_throw (terminate)>>>
    }
}


std::move<std::allocator<char>&> (struct allocator & __t)
{
  struct type & D.40120;

  try
    {
      D.40120 = __t;
      return D.40120;
    }
  catch
    {
      <<<eh_must_not_throw (terminate)>>>
    }
}


std::__cxx11::basic_string<char>::_Alloc_hider::_Alloc_hider (struct _Alloc_hider * const this, char * __dat, struct allocator & __a)
{
  MEM[(struct  &)this] = {CLOBBER};
  {
    _1 = std::move<std::allocator<char>&> (__a);
    std::allocator<char>::allocator (this, _1);
    try
      {
        this->_M_p = __dat;
      }
    catch
      {
        std::allocator<char>::~allocator (this);
      }
  }
}


std::char_traits<char>::copy (char_type * __s1, const char_type * __s2, size_t __n)
{
  char_type * D.40124;

  if (__n == 0) goto <D.40122>; else goto <D.40123>;
  <D.40122>:
  D.40124 = __s1;
  // predicted unlikely by early return (on trees) predictor.
  return D.40124;
  <D.40123>:
  D.40124 = __builtin_memcpy (__s1, __s2, __n);
  return D.40124;
}


std::__cxx11::basic_string<char>::~basic_string (struct basic_string * const this)
{
  try
    {
      {
        try
          {
            try
              {
                std::__cxx11::basic_string<char>::_M_dispose (this);
              }
            finally
              {
                _1 = &this->_M_dataplus;
                std::__cxx11::basic_string<char>::_Alloc_hider::~_Alloc_hider (_1);
              }
          }
        finally
          {
            MEM[(struct  &)this] = {CLOBBER};
          }
      }
      <D.37344>:
    }
  catch
    {
      <<<eh_must_not_throw (terminate)>>>
    }
}


std::allocator<char>::~allocator (struct allocator * const this)
{
  try
    {
      {
        try
          {

          }
        finally
          {
            __gnu_cxx::new_allocator<char>::~new_allocator (this);
          }
      }
      <D.37930>:
    }
  catch
    {
      <<<eh_must_not_throw (terminate)>>>
    }
}


__gnu_cxx::new_allocator<char>::~new_allocator (struct new_allocator * const this)
{
  try
    {
      {

      }
      <D.38340>:
    }
  catch
    {
      <<<eh_must_not_throw (terminate)>>>
    }
}


__static_initialization_and_destruction_0 (int __initialize_p, int __priority)
{
  if (__initialize_p == 1) goto <D.40126>; else goto <D.40127>;
  <D.40126>:
  if (__priority == 65535) goto <D.40128>; else goto <D.40129>;
  <D.40128>:
  std::ios_base::Init::Init (&__ioinit);
  __cxa_atexit (__dt_comp , &__ioinit, &__dso_handle);
  goto <D.40130>;
  <D.40129>:
  <D.40130>:
  goto <D.40131>;
  <D.40127>:
  <D.40131>:
}


_GLOBAL__sub_I_main ()
{
  __static_initialization_and_destruction_0 (1, 65535);
}


